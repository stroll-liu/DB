import{EventEmitter as e}from"events";import t from"deepmerge";import s from"clone";import r from"object-hash";import n from"memoizee";const o=e=>e.split("."),i=(e,t,s)=>{(e=((e,t)=>{for(var s=0;s<t.length-1;s++){const r=t[s];if(!e.hasOwnProperty(r))return;if(e=e[r],!a(e))return}if(e.hasOwnProperty(t[s]))return e})(e,t))&&s(e,t[t.length-1])},u=(e,t,s)=>{const r=(e,t)=>e[t]=s;l(e,t,r,r)},a=e=>"object"==typeof e&&null!==e,l=(e,t,s,r)=>{const n=t[t.length-1],o=s=>{e=((e,t,s)=>{for(let r=s;r<t.length-1;r++)e[t[r]]={},e=e[t[r]];return e})(e,t,s),r(e,n)};if(!e.hasOwnProperty(t[0]))return o(0);if(t.length>1){e=e[t[0]];for(let s=1;s<t.length-1;s++){const r=t[s];if(!a(e[r]))return;if(Array.isArray(e)&&r<0)return;if(!e.hasOwnProperty(r))return o(s);e=e[r]}}s(e,n)},c=(e,t,r)=>{const n=n=>{const o=[];for(let e of r)if(e[0]===n){if(1===e.length)return;o.push(e.slice(1))}if(o.length){const s=e[n];t[n]=new s.constructor,c(s,t[n],o)}else t[n]=s(e[n])};for(let t in e)n(t)},h=(e,t)=>{const s=new e.constructor;return c(e,s,t),s},d=(e,t,s)=>{for(var r=0;r<s.length-1;r++){const n=s[r];if(e=e[n],!a(e))return;t[n]=new e.constructor,t=t[n]}if(e.hasOwnProperty(s[r]))return t[s[r]]=e[s[r]],e},p=(e,s)=>{let r=[];for(let t of s){const s=new e.constructor;d(e,s,t)&&r.push(s)}return r.reduce(t,{})},f=(e,t)=>g(e)===g(t),_=e=>{throw Error(`unknown operator '${e}'`)},g=e=>void 0===e?"":r(e),y=e=>Error(e.target.error.message),x=Symbol("missing");class ${_doc;constructor(e){this._doc=e,this.get=n(this.get)}get(e){let t=x;return i(this._doc,e.pieces,((e,s)=>{t=e[s]})),t}ensure(e){for(let t of e)if(this.get(t)===x)return!1;return!0}}const w=(e,t)=>s=>{!function r(){e(((e,n,o)=>{n?t.run(new $(n))?s(null,n,o):r():s(e)}))}()},m=(e,t,s,r)=>{for(var n=0;n<s.length-1;n++){const o=s[n];if(e=e[o],t=t[o],a(e)){if(a(t))continue}else if(!a(t))return null;return r}const o=s[n];if(e.hasOwnProperty(o)){if(t.hasOwnProperty(o))return e=e[o],t=t[o],f(e,t)?0:(e<t?1:-1)*r}else if(!t.hasOwnProperty(o))return null;return r},b=(e,t)=>{const s=[];for(let e in t)s.push([o(e),t[e]]);const r=(e,t)=>{for(var[r,n]of s){const s=m(e,t,r,n);if(s>0||s<0)return s}return-n};let n=[];const i=e=>e(null,n.pop());let u=t=>{!function s(){e(((e,o)=>{if(!o)return(e=>{if(e)return t(e);n=n.sort(r),(u=i)(t)})(e);n.push(o),s()}))}()};return e=>u(e)};class v{pieces;literal;constructor(e){this.pieces=o(e),this.literal=e}}const A=globalThis,O=e=>{if("number"==typeof e)return!isNaN(e);if("string"==typeof e)return!0;if("boolean"==typeof e)return!0;if(!e)return!1;if(e.constructor===Object)return!1;if(Array.isArray(e)){for(let t of e)if(!O(t))return!1;return!0}return e instanceof Date&&!isNaN(e.valueOf())};let S=class{_is_index_matchable;getClauses(){return this._is_index_matchable?[this]:[]}};class T extends S{args;constructor(e){super(),this.args=e}}class k extends T{getClauses(){const e=[];for(let t=0;t<this.args.length;t++){const s=this.args[t];s instanceof T?e.push(...s.getClauses()):s.is_index_matchable&&(s.parent=this,s.index=t,e.push(s))}return e}run(e){for(let t of this.args)if(!t.run(e))return!1;return!0}}class R extends T{getClauses(){return[]}run(e){for(let t of this.args)if(t.run(e))return!0;return!1}}class j extends k{getClauses(){return[]}run(e){return!super.run(e)}}class P extends S{path;bool;constructor(e,t){super(),this.path=e,this.bool=t}get is_index_matchable(){return!!this.bool}run(e){return e.get(this.path)!==x===this.bool}}class C extends S{path;value;constructor(e,t){super(),this.path=e,this.value=t}get is_index_matchable(){return O(this.value)}get idb_key_range(){return A.IDBKeyRange.only(this.value)}run(e){const t=e.get(this.path);return t!==x&&f(t,this.value)}}class E extends C{get is_index_matchable(){return!1}run(e){return!super.run(e)}}class I extends S{path;fns;values;constructor(e,t,s){super(),this.path=e,this.fns=t,this.values=s}get is_index_matchable(){return!0}run(e){const t=e.get(this.path);if(t===x||null==t)return!1;const{fns:s,values:r}=this;for(let e=0;e<s.length;e++)if(!s[e](t,r[e]))return!1;return!0}}const D=(...e)=>class extends I{constructor(t,s){super(t,e,s)}},B=(e,t)=>e>t,M=(e,t)=>e>=t,N=(e,t)=>e<t,U=(e,t)=>e<=t;class K extends(D(B)){get idb_key_range(){return A.IDBKeyRange.lowerBound(...this.values,!0)}}class V extends(D(M)){get idb_key_range(){return A.IDBKeyRange.lowerBound(...this.values)}}class q extends(D(N)){get idb_key_range(){return A.IDBKeyRange.upperBound(...this.values,!0)}}class z extends(D(U)){get idb_key_range(){return A.IDBKeyRange.upperBound(...this.values)}}class W extends(D(B,N)){get idb_key_range(){return A.IDBKeyRange.bound(...this.values,!0,!0)}}class F extends(D(M,N)){get idb_key_range(){return A.IDBKeyRange.bound(...this.values,!1,!0)}}class L extends(D(B,U)){get idb_key_range(){return A.IDBKeyRange.bound(...this.values,!0,!1)}}class H extends(D(M,U)){get idb_key_range(){return A.IDBKeyRange.bound(...this.values)}}class Y extends S{path;op;constructor(e,t){super(),this.path=e,this.op=t}get is_index_matchable(){return!1}run(e){const t=e.get(this.path);if(!t||!t[Symbol.iterator])return!1;const{op:s}=this;for(let e of t)if(a(e)&&s.run(new $(e)))return!0;return!1}}class G extends S{path;expr;constructor(e,t){super(),this.path=e,this.expr=t}get is_index_matchable(){return!1}run(e){const t=e.get(this.path);return t!==x&&this.expr.test(t)}}const J=(e,t)=>{const s=[];for(let e of t){const t=ee(e);t&&s.push(t)}return s.length&&e.push(new j(s)),!0},Q={$and:(e,t)=>{for(let s of t){const t=ee(s);if(!1===t)return!1;t&&(t.constructor===k?e.push(...t.args):e.push(t))}return!0},$or:(e,t)=>{const s=[];let r;for(let e of t){const t=ee(e);t?t.constructor===R?s.push(...t.args):s.push(t):!1===t&&(r=!0)}if(s.length>1)e.push(new R(s));else if(s.length)e.push(s[0]);else if(r)return!1;return!0},$not:J,$nor:J},X=[[W,"$gt","$lt"],[F,"$gte","$lt"],[L,"$gt","$lte"],[H,"$gte","$lte"],[K,"$gt"],[V,"$gte"],[q,"$lt"],[z,"$lte"]],Z=(e,t,s)=>{const r=()=>(e.push(new C(t,s)),!0);if(null==s||s.constructor!==Object)return r();const n=new Set(Object.keys(s));if(n.has("$exists")&&!s.$exists)return e.push(new P(t,!1)),!0;const o=[];if(n.has("$eq")&&(o.push(new C(t,s.$eq)),n.delete("$eq")),n.has("$ne")&&(o.push(new E(t,s.$ne)),n.delete("$ne")),!((e,t,s,r)=>{const n=(n,o)=>{const i=[];for(let e of o){if(!r.has(e))return;const t=s[e];if(!O(t))return!1;i.push(t)}return e.push(new n(t,i)),!0};for(let[e,...t]of X){const s=n(e,t);if(!1===s)return;if(s){r.delete("$gt"),r.delete("$gte"),r.delete("$lt"),r.delete("$lte");break}}return!0})(o,t,s,n))return!1;if(n.has("$in")){const e=[];for(let r of s.$in)e.push(new C(t,r));e.length>1?o.push(new R(e)):e.length&&o.push(e[0]),n.delete("$in")}if(n.has("$nin")){for(let e of s.$nin)o.push(new E(t,e));n.delete("$nin")}if(n.has("$elemMatch")){const e=ee(s.$elemMatch);e&&o.push(new Y(t,e)),n.delete("$elemMatch")}if(n.has("$regex")){const e=new RegExp(s.$regex,s.$options);o.push(new G(t,e)),n.delete("$regex"),n.delete("$options")}s.$exists&&!o.length&&(o.push(new P(t,!0)),n.delete("$exists"));for(let e of n)"$"===e[0]&&_(e);return o.length?(e.push(...o),!0):r()},ee=e=>{const t=[];for(let s in e){let r,n=e[s];if("$"!==s[0])r=Z(t,new v(s),n);else{Array.isArray(n)||(n=[n]);const e=Q[s];e||_(s),r=e(t,n)}if(!r)return r}if(t.length)return 1===t.length?t[0]:new k(t)},te=e=>e.openCursor(),se=e=>{const{pipeline:s}=e,r=[],n=[];let o=0;for(let[e,t]of s){if(e===b)n.push(t);else{if(e!==w)break;r.push(t)}o++}s.splice(0,o),e.pred=(e=>e.length>1?new k(e):e[0])(r),n.length&&(e.sort_spec=n.reduce(t,{}))},re=e=>{const{col:t,pred:s}=e;e.clauses=((e,t)=>{if(!t)return[];const s=[],r=[];for(let n of t.getClauses())e._isIndexed(n.path.literal)&&(n instanceof P?r.push(n):s.push(n));return s.length?s:r})(t,s)},ne=e=>{let t,s;const r=(({pred:e,clauses:t,pipeline:s})=>{let r;if(t.length){const s=t[0];if(r=e=>((e,t)=>{const s=t.idb_key_range||null,r=t.idb_direction||"next",{literal:n}=t.path;let o;return o="_id"===n?e:e.index(n),o.openCursor(s,r)})(e,s),!e||s===e)return r;(({parent:e,index:t})=>{e.args.splice(t,1)})(s)}else if(r=te,!e)return r;return s.unshift([w,e]),r})(e),n=e=>{s.onsuccess=s=>{t=s.target.result,e()},s.onerror=t=>e(y(t))},o=e=>{n(e),t.continue()};let i=u=>{(({col:e,read_pref:t},s)=>{e._db._getConn(((r,n)=>{if(r)return s(r);const o=e._name;try{const e=n.transaction([o],t);e.onerror=e=>s(y(e)),s(null,e.objectStore(o))}catch(r){s(r)}}))})(e,((e,a)=>{if(e)return u(e);s=r(a),n((e=>{t&&(i=o),u(e)}))}))};return e=>i((s=>e(s,t)))},oe=({pipeline:e},t)=>{for(let[s,r]of e)t=s(t,r);return t},ie=e=>{const t=[],s=e.pred.args;for(let r=s.length-1;r>=0;r--){const n={col:e.col,read_pref:e.read_pref,pred:s[r],pipeline:[]};re(n);const o=ue(n);t.push(oe(n,o))}const r=new Set,n=()=>t.pop();let o=n();const i=e=>{o(((t,s,u)=>{t?e(t):s?(e=>{const t=g(e._id);if(!r.has(t))return r.add(t)})(s)?e(null,s,u):i(e):(e=>{(o=n())?i(e):e()})(e)}))},u=e.sort_spec;return u&&e.pipeline.push([b,u]),i},ue=e=>{const t=ne(e);return e=>{t(((t,s)=>{s?e(null,s.value,s):e(t)}))}},ae=e=>{let t;try{t=(e=>{const t=[];for(let[s,r]of e){if(s===w){const e=ee(r);if(!1===e)return;if(!e)continue;r=e}t.push([s,r])}return t})(e._pipeline)}catch(e){return t=>t(e)}if(!t)return e=>e();const s={col:e._col,read_pref:e._read_pref,hint:e._hint,pipeline:t};let r;return se(s),s.pred instanceof R?r=ie(s):(re(s),(e=>{if(!e.hint)return;const{clauses:t,hint:s}=e;let r=[];for(let e of t)e.path.literal===s&&r.push(e);r.length||(r=[{path:{literal:s}}]),e.clauses=r})(s),(e=>{if(!e.sort_spec)return;const{clauses:t,sort_spec:s,pipeline:r}=e,n=[];for(let e of t){const{literal:t}=e.path;if(!s.hasOwnProperty(t))continue;const r=s[t];e.idb_direction=r>0?"next":"prev",n.push(e)}n.length?e.clauses=n:r.unshift([b,s])})(s),r=ue(s)),oe(s,r)};class le{value;constructor(e){this.value=e}get ResultType(){return this.constructor}static any(e){return"number"==typeof e?new ce(e):"string"==typeof e?new he(e):Array.isArray(e)?new de(e):e instanceof Date?new pe(e):new le(e)}static literal(e){return new fe(le.any(e))}run(e){return this.value}}class ce extends le{static isType(e){return"number"==typeof e}}class he extends le{static isType(e){return"string"==typeof e}}class de extends le{static isType(e){return Array.isArray(e)}}class pe extends le{static isType(e){return e instanceof Date}}class fe extends le{get ResultType(){return this.value.ResultType}run(){return this.value.run()}}class _e{path;constructor(e){this.path=e}run(e){const t=e.get(this.path);return t===x?null:t}}class ge extends le{run(e){const t={},{value:s}=this;for(let r in s)t[r]=s[r].run(e);return t}}let ye=class{args;constructor(){this.args=[]}get alt(){return new le(null)}add(e){this.args.push(e)}};class xe extends ye{fn;constructor(e){super(),this.fn=e}get length(){return 1/0}run(e){const{args:t,fn:s}=this;return t.map((t=>t.run(e))).reduce(s)}}class $e extends xe{get length(){return 1}run(e){return this.fn(this.args[0].run(e))}}const we=(e,t)=>class extends e{constructor(){super(t)}},me=(e,t,s=t)=>{const r=class extends e{};return r.prototype.InputType=t,r.prototype.ResultType=s,r};class be extends(me(xe,ce)){}const ve=e=>we(be,e);class Ae extends(ve(((e,t)=>e+t))){}class Oe extends(ve(((e,t)=>e-t))){}class Se extends(ve(((e,t)=>e*t))){}class Te extends(ve(((e,t)=>e/t))){}class ke extends(ve(((e,t)=>e%t))){}class Re extends(me(xe,ce)){get length(){return this.fn.length}run(e){return this.fn(...this.args.map((t=>t.run(e))))}}const je=e=>we(Re,e);class Pe extends(je(Math.abs)){}class Ce extends(je(Math.ceil)){}class Ee extends(je(Math.floor)){}class Ie extends(je(Math.log)){}class De extends(je(Math.log10)){}class Be extends(je(Math.pow)){}class Me extends(je(Math.sqrt)){}class Ne extends(je(Math.trunc)){}class Ue extends(me(xe,he)){}class Ke extends(we(Ue,((e,t)=>e+t))){}class Ve extends(me($e,he)){get alt(){return new he("")}}class qe extends(we(Ve,(e=>e.toLowerCase()))){}class ze extends(we(Ve,(e=>e.toUpperCase()))){}class We extends(me(xe,de)){}class Fe extends(we(We,((e,t)=>e.concat(t)))){}class Le extends(me($e,pe,ce)){}const He=e=>we(Le,e);class Ye extends(He((e=>e.getDate()))){}class Ge extends(He((e=>e.getUTCFullYear()))){}class Je extends(He((e=>e.getUTCMonth()+1))){}class Qe extends(He((e=>e.getUTCHours()))){}class Xe extends(He((e=>e.getUTCMinutes()))){}class Ze extends(He((e=>e.getUTCSeconds()))){}class et extends(He((e=>e.getUTCMilliseconds()))){}class tt{result_types;stack;isType;args;op;alt_value;constructor(e,t,s){const{InputType:r,alt:n}=s;this.result_types=new Set([s.ResultType,n.ResultType]),this.stack=e,this.isType=r.isType,this.args=t,this.op=s,this.alt_value=n.value}run(e){const{stack:t,isType:s,op:r}=this,n=[];for(let t of this.args){const r=t.run(e);if(!s(r))return this.alt_value;n.push(r)}for(let e=n.length-1;e>=0;e--)t.push(n[e]);return r.run(e)}}class st{stack;constructor(e){this.stack=e}run(){return this.stack.pop()}}const rt={$add:Ae,$subtract:Oe,$multiply:Se,$divide:Te,$mod:ke,$abs:Pe,$ceil:Ce,$floor:Ee,$ln:Ie,$log10:De,$pow:Be,$sqrt:Me,$trunc:Ne,$concat:Ke,$toLower:qe,$toUpper:ze,$concatArrays:Fe,$dayOfMonth:Ye,$year:Ge,$month:Je,$hour:Qe,$minute:Xe,$second:Ze,$millisecond:et},nt=(e,t,s)=>{const r=rt[t];r||_(t),Array.isArray(s)||(s=[s]);const n=new r,o=[],i=[],u=[];for(let e=0;e<s.length&&e<n.length;e++){const t=ot(i,s[e]);if(t.ResultType){if(t.ResultType!==n.InputType)return n.alt;n.add(t)}else{if(t instanceof tt){if(!t.result_types.has(n.InputType))return n.alt;if(1===t.result_types.size){n.add(t);continue}}o.push(t),n.add(new st(u))}}return i.length?(e.push(...i),o.length?new tt(u,o,n):n):new n.ResultType(n.run())},ot=(e,t)=>{if("string"==typeof t&&"$"===t[0]){const s=new v(t.substring(1));return e.push(s),new _e(s)}return null==t||t.constructor!==Object?le.any(t):((e,t)=>{const s=new Set,r=new Set;for(let e in t)("$"===e[0]?s:r).add(e);if(s.size>1)throw Error("objects cannot have more than one operator");if(s.size){for(let e of r)throw Error(`unexpected field '${e}'`);for(let r of s)return"$literal"===r?le.literal(t[r]):nt(e,r,t[r])}const n=[],o={};for(let e in t)o[e]=ot(n,t[e]);const i=new ge(o);return n.length?(e.push(...n),i):new le(i.run())})(e,t)},it=e=>{const t=[];return{ast:ot(t,e),paths:t,has_refs:!!t.length}},ut=e=>{const{ast:t,paths:s,has_refs:r}=it(e);if(!r){const e=t.run();return(t,...s)=>u(s,e)}return(e,...r)=>{const n=new $(e);n.ensure(s)&&u(r,t.run(n))}},at=(e,t)=>{const s=e=>!!t[e];let r=!0;t.hasOwnProperty("_id")&&(r=s("_id"),delete t._id);const n=[],i=[];let u=!0;const a=e=>{if(s(e)!==u)throw Error("cannot mix inclusions and exclusions")};let l=e=>{u=s(e),l=a};for(let e in t){const s=t[e],r=o(e);"boolean"==typeof s||1===s||0===s?(l(e),n.push(r)):i.push([r,ut(s)])}const c=[];if(i.length&&c.push(((e,t)=>((e,t,s)=>{for(let[r,n]of s)n(e,t,r);return t})(e,t,i))),n.length){u===r&&n.push(["_id"]);const e=u?p:h;c.push((t=>e(t,n)))}else{let e;e=r?(e,t)=>{e.hasOwnProperty("_id")&&(t._id=e._id)}:(e,t)=>{delete t._id},c.push(((t,s)=>(e(t,s),s)))}return t=>{e(((e,s)=>{if(!s)return t(e);let r=s;for(let e of c)r=e(s,r);t(null,r)}))}};class lt{_value;get value(){return this._value}static getNoRefsSteps(e){return e.in_iter}static getOpValue(e,t){t(e.ast.run())}getOpValueWithRefs(e,t,s){const{ast:r,fields:n}=e;s(r.run(n))}}class ct extends lt{constructor(){super(),this._value=0}static _verify(e,t){"number"==typeof e&&t(e)}static getOpValue(e,t){super.getOpValue(e,(e=>ct._verify(e,t)))}getOpValueWithRefs(e,t,s){super.getOpValueWithRefs(e,t,(e=>{ct._verify(e,s)}))}add(e){this._value+=e}}class ht extends lt{_fn;_add;constructor(e){super(),this._value=null,this._fn=e,this._add=this._add1}static getNoRefsSteps(e){return e.in_end}_add1(e){this._value=e,this._add=this._add2}_add2(e){this._fn(e,this._value)&&(this._value=e)}add(e){null!=e&&this._add(e)}}const dt=(e,...t)=>{for(let s of e)s(...t)},pt=(e,t)=>{for(let s of t)dt(e,s)},ft=(e,t,s,r)=>n=>{!function o(){e(((e,i)=>{if(!i)return(e=>{e||pt(t,s),n(e,s)})(e);r(i),o()}))}()},_t=(e,t,s)=>{if(t.has_refs)return((e,t,s)=>{const{in_start:r,in_iter:o,in_end:i}=s,u=[],a=n(((e,t)=>{const s={_id:t};return u.push(s),dt(r,s),s}),{length:1}),{ast:l}=t,c=e=>l.run(new $(e));let h;return h=o.length?e=>{const t=c(e),s=a(g(t),t);dt(o,s,e)}:e=>{const t=c(e);a(g(t),t)},ft(e,i,u,h)})(e,t,s);const{in_start:r,in_iter:o,in_end:i}=s,u=[],a=()=>{const e={_id:t.ast.run()};return dt(r,e),u.push(e),e};if(o.length){const t=n((()=>a()));return ft(e,i,u,(e=>{dt(o,t(),e)}))}return t=>{e(((e,s)=>{s&&(a(),pt(i,u)),t(e,u)}))}},gt={$sum:ct,$avg:class extends ct{_count;constructor(){super(),this._count=0}add(e){this._count++,super.add(e)}get value(){return this._value/this._count||0}},$min:class extends ht{constructor(){super(((e,t)=>e<t))}},$max:class extends ht{constructor(){super(((e,t)=>e>t))}},$push:class extends lt{constructor(){super(),this._value=[]}add(e){this._value.push(e)}},$addToSet:class extends lt{_hashes;constructor(){super(),this._hashes={}}static getNoRefsSteps(e){return e.in_end}add(e){this._hashes[g(e)]=e}get value(){const e=[];for(let t in this._hashes)e.push(this._hashes[t]);return e}}},yt=(e,t,s)=>{const{in_start:r,in_iter:n,in_end:o}=e,i=Object.keys(s);if(i.length>1)throw Error("fields must have only one operator");const u=i[0],a=gt[u];if(!a)throw"$"===u[0]&&_(u),Error(`unexpected field '${u}'`);const l=it(s[u]);r.push((e=>{e[t]=new a(l)})),l.has_refs?n.push(((e,s)=>{const r=new $(s);if(!r.ensure(l.paths))return;const n=e[t],o=Object.assign({fields:r},l);n.getOpValueWithRefs(o,s,(e=>n.add(e)))})):a.getOpValue(l,(s=>{a.getNoRefsSteps(e).push((e=>{e[t].add(s)}))})),o.push((e=>{e[t]=e[t].value}))},xt=(e,t)=>{if(!t.hasOwnProperty("_id"))throw Error("the '_id' field is missing");const s=it(t._id),r=Object.assign({},t);delete r._id;const n={in_start:[],in_iter:[],in_end:[]};for(let e in r)yt(n,e,r[e]);const o=_t(e,s,n);let i=e=>{o(((t,s)=>{t?e(t):(i=e=>e(null,s.pop()))(e)}))};return e=>i(e)},$t=(e,t)=>{const s=o(t.substring(1)),r=[],n=e=>e(null,r.pop());let u=t=>{e(((e,o)=>{e?t(e):o?((e,t)=>{const o=r.length;if(i(e,s,((e,t)=>{const s=e[t];if(s&&s[Symbol.iterator])for(let e of s)r.push({[t]:e})})),o===r.length)return u(t);n(t)})(o,t):(u=n)(t)}))};return e=>u(e)},wt=(e,t)=>{let s=0;const r=n=>{e(((e,o)=>{o?++s>t?n(null,o):r(n):n(e)}))};return r},mt=(e,t)=>{let s=0;return r=>{s++<t?e(r):r()}};class bt extends e{_col;_read_pref;_pipeline;_next;_opened;_hint;constructor(e,t){super(),this._col=e,this._read_pref=t,this._pipeline=[],this._next=this._init}_forEach(e,t){this._next(((s,r)=>{r?(e(r),this.emit("forEachData",r),this._forEach(e,t)):(this.emit("forEachEnd"),t(s))}))}forEach(e=(e=>{})){return new Promise(((t,s)=>{const r=[];this._forEach((t=>{e(t),r.push(t)}),(e=>{e&&s(e)})),this.on("forEachEnd",(()=>{t(r)}))}))}_toArray(e){const t=[];this._forEach((e=>{t.push(e)}),(s=>e(s,t)))}toArray(){return new Promise(((e,t)=>{this._toArray(((s,r)=>{s?t(s):e(r)}))}))}_assertUnopened(){if(this._opened)throw Error("cursor has already been opened")}hint(e){if(this._assertUnopened(),!this._col._isIndexed(e))throw Error(`index '${e}' does not exist`);return this._hint=e,this}_addStage(e,t){return this._assertUnopened(),this._pipeline.push([e,t]),this}filter(e){return this._addStage(w,e)}limit(e){return this._addStage(mt,e)}skip(e){return this._addStage(wt,e)}project(e){return this._addStage(at,e)}group(e){return this._addStage(xt,e)}unwind(e){return this._addStage($t,e)}sort(e){return this._addStage(b,e)}_init(e){this._opened=!0,this._next=ae(this),this._next(e)}}const vt={$match:(e,t)=>e.filter(t),$project:(e,t)=>e.project(t),$group:(e,t)=>e.group(t),$unwind:(e,t)=>e.unwind(t),$sort:(e,t)=>e.sort(t),$skip:(e,t)=>e.skip(t),$limit:(e,t)=>e.limit(t)},At=e=>{const t=Object.keys(e);if(t.length>1)throw Error("阶段必须仅由一名操作员通过");const s=t[0],r=vt[s];return r||_(s),[r,e[s]]},Ot={$set:(e,t)=>s=>{u(s,e,t)}};Ot.$unset=e=>t=>((e,t)=>{for(var s=0;s<t.length-1;s++)if(e=e[t[s]],!a(e))return;if(Array.isArray(e)){const r=Number.parseFloat(t[s]);Number.isInteger(r)&&e.splice(r,1)}else delete e[t[s]]})(t,e),Ot.$rename=(e,t)=>s=>{((e,t,s)=>{i(e,t,((e,t)=>{e[s]=e[t],delete e[t]}))})(s,e,t)};const St=(e,t,s)=>r=>{l(r,e,t,s)},Tt=e=>(t,s)=>St(t,((t,r)=>{const n=t[r];"number"==typeof n&&(t[r]=e(s,n))}),((e,t)=>e[t]=0));Ot.$inc=Tt(((e,t)=>e+t)),Ot.$mul=Tt(((e,t)=>e*t));const kt=e=>(t,s)=>St(t,((t,r)=>{e(s,t[r])&&(t[r]=s)}),((e,t)=>e[t]=s));Ot.$min=kt(((e,t)=>e<t)),Ot.$max=kt(((e,t)=>e>t)),Ot.$push=(e,t)=>St(e,((e,s)=>{const r=e[s];Array.isArray(r)&&r.push(t)}),((e,s)=>e[s]=[t])),Ot.$pop=(e,t)=>{let s;return s=t<1?e=>e.shift():e=>e.pop(),t=>{i(t,e,((e,t)=>{const r=e[t];Array.isArray(r)&&s(r)}))}},Ot.$pullAll=(e,t)=>s=>{i(s,e,((e,s)=>{const r=e[s];if(!Array.isArray(r))return;const n=[],o=e=>{for(let s of t)if(f(e,s))return!0};for(let e of r)o(e)||n.push(e);e[s]=n}))},Ot.$pull=(e,t)=>Ot.$pullAll(e,[t]),Ot.$addToSet=(e,t)=>s=>{i(s,e,((e,s)=>{const r=e[s];if(Array.isArray(r)){for(let e of r)if(f(e,t))return;r.push(t)}}))};const Rt=(e,t,s)=>{if("$"!==t[0])return e.push(Ot.$set(o(t),s));const r=Ot[t];r||_(t);for(let t in s)e.push(r(o(t),s[t]))},jt=(e,t)=>{!function s(){e._next(((e,r,n)=>{if(!r)return t(e);const o=n.delete();o.onsuccess=s,o.onerror=e=>t(y(e))}))}()};class Pt{_db;_name;_indexes;constructor(e,t){this._db=e,this._name=t,this._indexes=new Set}get name(){return this._name}_isIndexed(e){return this._indexes.has(e)||"_id"===e}find(e,t){return new Promise(((s,r)=>{try{const r=new bt(this,"readonly");r.filter(e),t&&r.project(t),s(r)}catch(e){r(e)}}))}async findOne(e,t){return(await this.find(e,t).then((e=>e.limit(1)))).toArray()}aggregate(e){return((e,t)=>new Promise(((s,r)=>{try{const r=new bt(e,"readonly");for(let e of t){const[t,s]=At(e);t(r,s)}s(r)}catch(e){r(e)}})))(this,e)}_validate(e){for(let t in e){if("$"===t[0])throw Error("字段名称不能以以下内容开头 '$'");const s=e[t];if(Array.isArray(s))for(let e of s)this._validate(e);else"object"==typeof s&&this._validate(s)}}insert(e){return Array.isArray(e)||(e=[e]),new Promise(((t,s)=>{this._db._getConn(((r,n)=>{let o;const i=this._name;try{o=n.transaction([i],"readwrite")}catch(e){return s(e)}o.oncomplete=()=>t(!0),o.onerror=e=>s(y(e));const u=o.objectStore(i);let a=0;const l=()=>{const t=e[a];try{this._validate(t)}catch(e){return s(e)}u.add(t).onsuccess=()=>{a++,a<e.length&&l()}};l()}))}))}_modify(e,t){return new Promise(((s,r)=>{const n=new bt(this,"readwrite");n.filter(t),e(n,(e=>{e?r(e):s(!0)}))}))}update(e,t){return this._modify(((e,s)=>((e,t,s)=>{const r=[];for(let e in t)Rt(r,e,t[e]);if(!r.length)return s(null);!function t(){e._next(((e,n,o)=>{if(!n)return s(e);for(let e of r)e(n);const i=o.update(n);i.onsuccess=t,i.onerror=e=>s(y(e))}))}()})(e,t,s)),e)}remove(e){return this._modify(jt,e)}}const Ct=globalThis;const Et={Db:class extends e{_cols;_config;_name;_version;_idb;_open;constructor(e,t,s){if(super(),this._name=e,"object"==typeof t?s=t:this._version=t,this._cols={},this._config={},Array.isArray(s))for(let e of s)this._addCollection(e),this._config[e]=!0;else for(let e in s)this._addCollection(e),this._addIndex(s[e],e)}get name(){return this.name}get version(){return this.version}_addCollection(e){this._cols[e]=new Pt(this,e)}_addIndex(e,t){const s=this._config;if(!e)return s[t]=!1;if("object"!=typeof e)return s[t]={};const r=this._cols[t];if(Array.isArray(e)){const n={};for(let t of e)n[t]=!0,r._indexes.add(t);s[t]=n}else{for(let t in e)e[t]&&r._indexes.add(t);s[t]=e}}_addStore(e,t){const s=e.createObjectStore(t,{keyPath:"_id",autoIncrement:!0}),r=this._config[t];for(let e in r)r[e]?s.createIndex(e,e,{unique:!1}):s.deleteIndex(e)}_getConn(){return new Promise(((e,t)=>{let s;s=this._version?Ct.indexedDB.open(this._name,this._version):Ct.indexedDB.open(this._name),s.onsuccess=t=>{const s=t.target.result;this._idb=s,this._version=s.version,this._open=!0,e(s)},s.onerror=e=>t(y(e)),s.onupgradeneeded=e=>{const s=e.target.result;for(let e in this._config)try{this._config[e]?s.objectStoreNames.contains(e)||this._addStore(s,e):s.deleteObjectStore(e)}catch(e){return t(e)}},s.onblocked=()=>this.emit("blocked")}))}collection(e){return new Promise(((t,s)=>{const r=this._cols[e];r?t(r):s({code:0,mag:`collection '${e}' 不存在`})}))}open(){return this._getConn()}async close(){try{return this._open&&(this._idb.close(),this._open=!1),Promise.resolve(!0)}catch(e){return Promise.reject(!1)}}async drop(){return await this.close(),new Promise(((e,t)=>{const s=Ct.indexedDB.deleteDatabase(this._name);s.onsuccess=()=>e(!0),s.onerror=e=>t(y(e))}))}}};export{Et as Db,Et as default};
